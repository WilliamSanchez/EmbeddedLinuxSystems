#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/kernel.h>
#include <linux/slab.h>
#include <linux/of.h>
#include <linux/platform_device.h>
#include <linux/gpio/consumer.h>
#include <linux/input.h>

struct btn_data{
   struct gpio_desc *btn_gpiod;  
   struct input_dev *i_dev;
   struct platform_device *pdev;
   int irq;
};

static int btn_open(struct input_dev *i_dev)
{
   pr_info("input device opend\n");
   return 0;
}

static void btn_close(struct input_dev *i_dev)
{
   pr_info("input device closed\n");
}

static irqreturn_t btn_irq(int irq, void *dev_id)
{
   struct btn_data *priv=dev_id;
   input_report_key(priv->i_dev, BTN_0,gpiod_get_value(priv->btn_gpiod) & 1);
   input_sync(priv->i_dev);
   
   pr_info("Reporting an interrupt\n");
   return IRQ_HANDLED;
}

static const struct of_device_id btn_irq_ids[] = {
   {.compatible="button, input-button",},
   {}
};

static int btn_probe(struct platform_device *pdev)
{
 
    pr_info("Initilizing GPIO_IRQ device drive\n");
 
    struct btn_data *priv;
    struct gpio_desc *gpiod;
    struct input_dev *i_dev;
    int ret;
    
    priv=devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
    if(!priv)
    	return -ENOMEM;

    i_dev=input_allocate_device();
    if(!i_dev)
     	return -ENOMEM;

    i_dev->open=btn_open;
    i_dev->close=btn_close;
    i_dev->name="Irq_WGPIO";
    i_dev->dev.parent=&pdev->dev;
    priv->i_dev = i_dev;
    priv->pdev=pdev;

    /* Declare the events generated by this driver  */
    set_bit(EV_KEY, i_dev->evbit);
    set_bit(BTN_0, i_dev->keybit); /*buttons*/
    
    /*  We assume this GPIO is active high */
    gpiod = gpiod_get(&pdev->dev,"sw",GPIOD_IN);
    
     pr_err("geting gpiod\n");

     if(IS_ERR(gpiod))
	return -ENODEV;
	
     pr_err("getting gpiod success\n");	
   	
     priv->irq = gpiod_to_irq(gpiod);
     priv->btn_gpiod=gpiod;

     ret = input_register_device(priv->i_dev);
     if(ret)
     {
         pr_err("Failed to register input device\n");
         goto err_input;
     }

     //ret = request_threaded_irq(priv->irq, NULL, btn_irq,  IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING|IRQF_ONESHOT, "GPIO_irq_BUTN", NULL);
     ret = request_any_context_irq(priv->irq, btn_irq, (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING), "GPIO_irq_BUTN", priv);     
     if(ret < 0)
     {
          dev_err(&pdev->dev, "Unable to acquire interrupt for GPIO line\n");
          goto err_btn;
     }
     
     platform_set_drvdata(pdev,priv);
     pr_info("Finalized GPIO_IRQ device drive\n");
     
     return 0;
     
     err_btn:
     	gpiod_put(priv->btn_gpiod);
     
     err_input:
     	input_free_device(i_dev);
     return ret;
     
}

static int btn_remove(struct platform_device *pdev)
{
   struct btn_data *priv;
   priv=platform_get_drvdata(pdev);
   input_unregister_device(priv->i_dev);
   input_free_device(priv->i_dev);
   free_irq(priv->irq,priv);
   gpiod_put(priv->btn_gpiod);
   
   return 0;
}

static struct platform_driver gpio_drv={

   .probe = btn_probe,
   .remove = btn_remove,
   .driver={
   	.name = "irq_Wgpio",
   	.of_match_table = of_match_ptr(btn_irq_ids),
   	.owner = THIS_MODULE,
   	},
};

module_platform_driver(gpio_drv);

MODULE_AUTHOR("William Sanchez");
MODULE_DESCRIPTION("GPIO, Interrupt input");
MODULE_LICENSE("GPL");
MODULE_ALIAS("platform:GPIO-IRQ input");

